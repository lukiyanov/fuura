#pragma once
#include <memory>

namespace fuura::compilation::memory
{
	///////////////////////////////////////////////////////////////////////////////
	//
	//	Менеджер памяти, пригодной для записи в неё исполняемого кода.
	//
	//	На современных версиях Windows new и malloc возвращают память,
	//	непригодную для выполнения - только для чтения-записи. Соответственно,
	//	при попытке исполнения откомпилированного JIT кода мы получим исключение
	//	благодаря механизму DEP (Data Execution Preventing).
	//
	//	Чтобы этого не происходило, нужен пратформо-специфический выделитель
	//	памяти, пригодной для исполнения. Данный класс именно им и является.
	//
	///////////////////////////////////////////////////////////////////////////////
	class IExecutableMemoryManager
	{
	public:
		// --------------------------------------------------------------------------
		// Выделяет исполняемую память под шеллкод и возвращает указатель на неё.
		// Подразумевается, что потомки должны реализовать её корректное автоматическое удаление,
		// в т.ч. и в случае если менеджер был удалён ДО удаления созданного им объекта.
		// Возвращает shared_ptr, т.к. реализация может определять свой пользовательский удалитель.
		// --------------------------------------------------------------------------
		virtual std::shared_ptr<void> PlaceToExecutableMemory(const void* shellCode, size_t codeSizeInBytes) = 0;
	};

	///////////////////////////////////////////////////////////////////////////////
}