#pragma once
#include <list>
#include <vector>
#include <map>
#include "FunctionWrapper.h"

namespace fuura::language
{
	///////////////////////////////////////////////////////////////////////////
	//
	//	Набор перегруженных функций, имеющих одно имя и количество аргументов.
	//
	///////////////////////////////////////////////////////////////////////////
	class FunctionSetWithFixedArgumentCount
	{
	public:
		// --------------------------------------------------------------------
		using Container = std::vector<std::unique_ptr<IFunctionWrapper>>;

		// --------------------------------------------------------------------
		// Генерирует исключение, если такая функция уже существует.
		// --------------------------------------------------------------------
		void Insert(std::unique_ptr<IFunctionWrapper> function);

		// --------------------------------------------------------------------
		Container::iterator Begin() { return m_functions.begin(); }

		// --------------------------------------------------------------------
		Container::iterator End() { return m_functions.end(); }

	private:
		// Такой организации достаточно, т.к. большого количества перегрузок не ожидается.
		// Тначе можно было бы сделать таблицу { число_аргументов х число_типов } со
		// временем поиска точного совпадения О(1). Пока же смысла всё усложнять нет.
		Container m_functions;
	};

	///////////////////////////////////////////////////////////////////////////
	//
	//	Набор перегруженных функций, имеющих одно имя.
	//
	///////////////////////////////////////////////////////////////////////////
	class OverloadedFunctionSet
	{
	public:
		// --------------------------------------------------------------------
		// Генерирует исключение, если такая функция уже существует.
		// --------------------------------------------------------------------
		void Insert(std::unique_ptr<IFunctionWrapper> function);

		// --------------------------------------------------------------------
		// Возвращает nullptr, если функций с таким числом параметров нет.
		// --------------------------------------------------------------------
		FunctionSetWithFixedArgumentCount* Find(size_t argCount);

	private:
		// Группируются по числу аргументов.
		std::map<size_t, FunctionSetWithFixedArgumentCount> m_functions;
	};

	///////////////////////////////////////////////////////////////////////////
}