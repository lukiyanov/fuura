#pragma once
#include <list>
#include <vector>
#include <ostream>
#include "RegisterType.h"

namespace fuura::compilation
{
	class VirtualRegister;
	class VirtualRegisterProxy;

	// TODO: VirtualRegisterUnion, но пока уже написанный код не будет полностью интергирован в процесс компиляции, этот класс не нужен.

	///////////////////////////////////////////////////////////////////////////
	//
	//	Менеджер виртуальных регистров (ВР), отвечает за создание ВР и хранит
	//	все данные созданных им ВР.
	//
	///////////////////////////////////////////////////////////////////////////
	class VirtualRegisterManager
	{
		friend class VirtualRegister;

	public:
		// --------------------------------------------------------------------
		// Создают ВР указанного типа.
		// --------------------------------------------------------------------
		VirtualRegister AllocateInt8();
		VirtualRegister AllocateInt16();
		VirtualRegister AllocateInt32();
		VirtualRegister AllocateFloat64();

		// --------------------------------------------------------------------
		// Возвращает состояние всех созданных менеджером регистров.
		// --------------------------------------------------------------------
		const std::vector<VirtualRegisterProxy>& GetAllocatedRegisters() const;

	private:
		inline VirtualRegister Allocate(RegisterType type);

	private:
		struct VRData
		{
			RegisterType type;			// Тип регистра: int32, int16, int8, float64 и т.д.
			bool		 isSet;			// Подставлено ли в ВР значение конкретного регистра?
			int			 value;			// Если конкретный регистр подставлен, то он хранится здесь.
			int			 uid;			// Уникальный номер регистра, по сути нужен только для читабельного отладочного вывода.
			int			 chainLength;	// Текущая длина цепочки использований ВР.
			bool		 isActual;		// Признак того, что цепочка ВР ещё не завершена на данный момент.

			VRData(RegisterType Type, int UID)
				: type(Type), uid(UID), isSet(false), chainLength(1), isActual(true)
			{}
		};

		// list - чтобы структуры не перемещались в памяти и их адрес не менялся,
		// соответственно указатели на структуры VRData будут оставаться валидными.
		std::list<VRData> m_registerData;

		// Нужен только для GetAllocatedRegisters().
		// Хранить такой вектор дешевле чем при каждом вызове создавать новый.
		// Proxy - чтобы можно было нормально копировать контейнеры с ними
		// и не опасаться за увеличение длины цепочки.
		std::vector<VirtualRegisterProxy> m_registerCopies;
	};


	///////////////////////////////////////////////////////////////////////////
	//
	//	Класс виртуального регистра (ВР).
	//	Это временная замена физического регистра для объектов "ассемблерная инструкция", своеобразный плэйсхолдер.
	//	В отличие от физических, их можно создать сколько угодно. Каждый ВР имеет свой уникальный номер (имя, UID).
	//	В момент генерации кода в каждый из ВР должно быть установлено значение, какому физическому регистру он соответствует, иначе возникнет исключение.
	//	ВР объединяются в "цепочки использований":
	//	- в ассемблерной команде где ВР с некоторым UID фиругирует впервые мы говорим что цепочка создаётся;
	//	- когда некоторая команда использует значение ВР и в нём же возвращает своё значение, мы говорим что она продолжает цепочку использований ВР;
	//	- в последней команде где фигурирует ВР с данным UID мы говорим что в этой команде цепочка использований регистра завершается.
	//
	//	Менеджер виртуальных регистров контролирует создание ВР и ведёт подсчёт времени жизни цепочек.
	//	Т.е. того, который из созданных менеджером ВР в каких инструкциях ассемблерного листинга создаётся/используется и за какой командой его использование прекращается.
	//	Значение ВР - это регистр который в него подставлен.
	//
	///////////////////////////////////////////////////////////////////////////
	//
	//	Подробнее, каждый виртуальный регистр:
	//	- Обозначает что в данное место должен быть подставлен один из регистров определённого типа и хранит подставленное значение.
	//		Например, для ВР типа I32 значениями будут eax, ebx, ecx, edx, esi, edi, esp и ebp.
	//		- При создании в ВР не подставлено никакого конкретного регистра, но он должен быть обязательно установлен позднее.
	//		- ВР позволяет узнать, установлено ли его значение или нет.
	//		- ВР позволяет считать своё значение. Если при этом значение не установлено, генерируется исключение.
	//
	//	- Может быть создан двумя путями:
	//		- Через менеджер ВР, в этом случае созданный ВР получает новый UID и в этой точке начинается цепочка его использований (см.ниже).
	//		- При создании через конструктор копирования, в этом случае происходит увеличение длины исходной цепочки, а оба ВР будут указывать на один и тот же регистр:
	//				auto reg1 = reg2;
	//			Тут reg1 и reg2 будут иметь общий счётчик длины цепочки, а установка значения в один объект приведёт к установке и в другой.
	//			Принцип работы похож на std::shard_ptr с той разницей что тут данные на самом деле хранятся в менеджере.
	//
	//	- Ведёт подсчёт длины цепочки использований регистра. Подробнее об этом моменте, т.к. он ключевой в распределении регистров:
	//		- При создании при помощи менеджера, ВР получает длину цепочки 1 и уникальное имя (т.е. номер, UID). Отсюда начинается цепочка использований,
	//		обозначающая многочисленные вхождения в листинг одного и того же регистра, когда каждая команда использует хранящееся в нём значение,
	//		изменяет его и снова возвращает значение в том же регистре. Например:
	//			mov reg1, 3		// создание регистра reg1, длина цепочки его использования = 1
	//			inc reg1		// inc получает аргумент в reg1 и возвращает свой результат в этом же регистре, длина цепочки использования reg1 становится = 2
	//			sub reg1, 4		// длина цепочки = 3
	//		- Команда, которая НЕ возвращает результат в том же регистре в котором получает свой аргумент - завершает цепочку. Например:
	//			sub reg1, reg2	// удлиняет на 1 цепочку использований reg1 и завершает цепочку для reg2
	//		- Команды вроде "add reg1, reg2" являются коммутативными и могут возвращать результат в любом из двух регистров-аргументов ("add reg1, reg2" для reg1 и "add reg2, reg1" для reg2),
	//			в таких случаях используются ВР-объединения (Union), которые позволяют отложить выбор порядка следования регистров до момента когда станет понятно, какой из них является предпочтительным.
	//		- Конкретные регистры в ВР могут подставляться в любом порядке. Например, известно что div принимает аргументы в паре eax:edx.
	//			Следовательно, соответствующие виртуальные регистры этой команды становятся eax и edx.
	//			Команды, принимающие аргументы или возвращающие результат в строго определённых регистрах далее именуются регистро-зависимыми.
	//		- При подстановках регистров могут возникнуть конфликтные ситуации (коллизии), когда в ВР требуется установить некоторое значение, а он уже содержит другое.
	//			Непосредственно ВР разрешением коллизий не занимается - их появление должен предусмотреть и обработать использующий ВР код.
	//
	///////////////////////////////////////////////////////////////////////////
	class VirtualRegister
	{
	private:
		friend class VirtualRegisterManager;
		friend class VirtualRegisterProxy;

		// --------------------------------------------------------------------
		// Закрытый конструктор, создание объектов разрешено только менеджеру ВР.
		// В нём же и хранятся данные по всем созданным им ВР, поэтому срок
		// жизни менеджера не должен быть короче срока жизни созданных им ВР.
		// --------------------------------------------------------------------
		VirtualRegister(VirtualRegisterManager::VRData* data);

	public:

		// --------------------------------------------------------------------
		// Увеличивает длину цепочки на 1.
		// --------------------------------------------------------------------
		VirtualRegister(const VirtualRegister& source);

		// --------------------------------------------------------------------
		// Конструктор перемещения не изменяет длину цепочки.
		// --------------------------------------------------------------------
		VirtualRegister(VirtualRegister&& source) = default;

		// --------------------------------------------------------------------
		// Оператор присваивания отсутствует.
		// --------------------------------------------------------------------
		VirtualRegister& operator = (VirtualRegister& source) = delete;

		// --------------------------------------------------------------------
		// Два регистра равны если принадлежат к одной цепочке
		// (или имеют один UID, что одно и то же).
		// --------------------------------------------------------------------
		bool operator == (const VirtualRegister& reg) const;
		bool operator != (const VirtualRegister& reg) const;

		// --------------------------------------------------------------------
		// Возвращает уникальный номер регистра от 1 и до бесконечности.
		// --------------------------------------------------------------------
		int GetUID() const;

		// --------------------------------------------------------------------
		// Возвращает тип регистра. Регистры одного типа считаются, как правило,
		// взаимозаменяемыми.
		// --------------------------------------------------------------------
		RegisterType GetType() const;

		// --------------------------------------------------------------------
		// Подставлено ли значение конкретного регистра?
		// --------------------------------------------------------------------
		bool IsSet() const;

		// --------------------------------------------------------------------
		// Помимо установки значения проверяют соответствие типа регистра и
		// типа устанавливаемого значения. Генерируют исключение если они
		// различны.
		// --------------------------------------------------------------------
		void SetValue(RegisterInt8    reg);
		void SetValue(RegisterInt16   reg);
		void SetValue(RegisterInt32   reg);
		void SetValue(RegisterFloat64 reg);

		// --------------------------------------------------------------------
		// Возвращают значение регистра. Помимо этого также проверяют
		// соответствие типов и генерируют исключение если они не совпали.
		// Также генерирует исключение если значение не установлено.
		// --------------------------------------------------------------------
		RegisterInt8    GetValueAsInt8()    const;
		RegisterInt16   GetValueAsInt16()   const;
		RegisterInt32   GetValueAsInt32()   const;
		RegisterFloat64 GetValueAsFloat64() const;

		// --------------------------------------------------------------------
		// Возвращает текущую длину цепочки использований данного регистра.
		// --------------------------------------------------------------------
		int GetChainLength() const;

		// --------------------------------------------------------------------
		// Пользователь обязательно должен вызвать эту функцию в последней
		// команде, использующей данный ВР.
		// --------------------------------------------------------------------
		void EndChain();

		// --------------------------------------------------------------------
		// Возвращает true, если цепочка ВР ещё не завершена, иначе false.
		// --------------------------------------------------------------------
		bool IsActual() const;

	private:
		// Генерирует исключение при несовпадении типов.
		template <class RegisterTypeT>
		inline void CheckTypes() const;

		// Генерирует исключение если значение не установлено.
		inline void CheckSet() const;

		// Обобщённая версия SetValue.
		template <class RegisterTypeT>
		inline void SetValue(RegisterTypeT reg);

		// Обобщённая версия GetValueAsXXX.
		template <class RegisterTypeT>
		inline RegisterTypeT GetValueAs() const;


	protected:
		// На самом деле все данные хранит создавший ВР менеджер;
		// он же отвечает за их уничтожение, поэтому указатель невладеющий.
		VirtualRegisterManager::VRData* m_data;
	};

	///////////////////////////////////////////////////////////////////////////
	//
	//	Отличается от VirtualRegister только тем что не увеличивает длину
	//	цепочки при копировании и наличием оператора присваивания
	//	(также не увеличивающего счётчик).
	//
	///////////////////////////////////////////////////////////////////////////
	class VirtualRegisterProxy : public VirtualRegister
	{
	public:
		VirtualRegisterProxy(const VirtualRegister& source);
		VirtualRegisterProxy(const VirtualRegisterProxy& source);
		VirtualRegisterProxy& operator = (VirtualRegisterProxy& source);
	};

	// --------------------------------------------------------------------
	// Для отладочного вывода. Выводит в поток название вроде vrd3, где:
	//		vr - "virtual register"
	//		d  - тип регистра (см. RegisterType::operator char())
	//		3  - UID регистра
	// --------------------------------------------------------------------
	std::ostream& operator << (std::ostream& out, const VirtualRegister& vr);

	// --------------------------------------------------------------------
	// Для отладочного вывода. Выводит в поток нечто похожее на:
	//		[vrd1:1, vrd2:3, vrb3:1], где:
	//		"vrd1"     - название ВР;
	//		":<число>" - длина соответствующей ему цепочки.
	//		В поток выводятся только ВР с незавершёнными цепочками.
	// --------------------------------------------------------------------
	std::ostream& operator << (std::ostream& out, const VirtualRegisterManager& vrm);

	///////////////////////////////////////////////////////////////////////////
}