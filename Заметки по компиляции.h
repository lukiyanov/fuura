(1 + 10 * 3) % 2 + (4 + 5)
// => (приоритета операндов нет): 10 * 3 + 1 % 2 + 4 + 5

NB: imul и idiv оба используют eax:edx





/// Схема получения конечного результата:
	// Дерево таких объектов даёт возможность выполнить выражение.
	// language::Const<T> : public ICalculatable - один шаблон для всех типов
1.	std::string -> ANTLR4 -> language::Const<int>("10")
	
	// Дерево таких объектов после подстановки регистров даёт возможность скомпилировать конечный машинный код.
	// Учитывает особенности компиляции конкретной команды.
	// compilation::Const<T> : public IDependency - неполный тип, существующий только в виде специализаций
2.	-> compilation::Const<int>("10")
		-> reg1 = const(10)		// Текстовое представление объекта
		
3.	// Шаг 3: Оптимизация.
	3.1. // Свёртка констант.
	// TODO
	3.2. // Разложение выражений вида a - (b + c) в a - b - c, а также a * (b * c) => a * b * c.
	// TODO
	3.3. // Сортировка операндов дерева по длине зависимостей
	// TODO
	3.4. // Прогон по списку шаблонов оптимизации.
	// NB: про это есть ниже.
	// TODO
	Пока специально игнорируем оптимизацию чтобы убедиться в корректности распределения регистров даже на плохих случаях.
		
	// Шаг 4: Распределение регистров.
	// NB: важную роль тут играет хранилище временных регистров, которое определяет, какие регистры задействованы на момент каждой команды.
4.	-> tree.SetCmdDependentRegisters();	// Подстановка регистров в команды вроде idiv
	   tree.SetResultRegister(eax);		// Конечный регистр = eax				// NB: эта команда есть у всех
	   tree.ResolveRegisters();			// Разрешение всех прочих регистров.
		-> eax  = const(10)		// Текстовое представление объекта
		
	// Шаг 5: компиляция.
5.	-> tree.Build(compiler);
		-> mov eax, 10

Compiler переименовать в AsmTranslator

{
Const<int>(C) -> DepConst<int>(C) > "..."
// Формат:
eax	           = const(10)		// занято:[a]	// захват a
}

// После сортировки по длине:
reg1	 = const(10)
reg2	 = const(3)
U(1,2)	 = mul(reg1, reg2)	// коммутативная команда
reg3	 = const(1)
U(1,2,3) = add(U(1,2), reg3)	// снова коммутативная команда
reg4	 = const(2)
[eax,edx]= idiv(U(1,2,3), reg4)	// фейковые регистры, создаются и один из них тут же уничтожается
reg5	:= edx
reg6	 = const(4)
reg7	 = const(5)
U(6,7)	 = add(reg6, reg7)
U(5,6,7) = add(reg5, U(6,7))

// 1. div: d1 = eax, r1 = edx
reg1	= const(10)
reg2	= const(3)
U(1,2)	= mul(reg1, reg2)
reg3	= const(1)
U(1,2,3)= add(U(1,2), reg3)
reg4	= const(2)
[eax,edx] = idiv(U(1,2,3), reg4)
[reg5	:= edx]						//	считывание из fake reg => на самом деле эта команда не генерируется
reg6	= const(4)
reg7	= const(5)
U(6,7)	= add(reg6, reg7)
U(5,6,7)= add(reg5, U(6,7))

// 1. idiv: d1 = eax, r1 = edx
reg1	= const(10)
reg2	= const(3)
U(1,2)	= mul(reg1, reg2)
reg3	= const(1)
U(1,2,3)= add(U(1,2), reg3)
reg4	= const(2)
[eax,edx] = idiv(U(1,2,3), reg4)
reg5	:= edx						//	считывание из fake reg => на самом деле эта команда не генерируется
reg6	= const(4)
reg7	= const(5)
U(6,7)	= add(reg6, reg7)
U(5,6,7)= add(reg5, U(6,7))

// 2. idiv: U(1,2,3) - eax
// Выбираем так:
/*
	На каждой развилке (коммутативной команде):
		...
		Иначе целевой регистр - самая длинная ветвь.
*/
reg1	= const(10)
reg2	= const(3)
U(1,2)	= mul(reg1, reg2)
reg3	= const(1)
eax		= add(U(1,2), reg3)
reg4	= const(2)
[eax,edx] = idiv(eax, reg4)
[reg5	:= edx]
reg6	= const(4)
reg7	= const(5)
U(6,7)	= add(reg6, reg7)
U(5,6,7)= add(reg5, U(6,7))

// 2.1 развилка
reg1	= const(10)
reg2	= const(3)
eax		= mul(reg1, reg2)
reg3	= const(1)
eax		= add(eax, reg3)		// U(1,2) длиннее чем reg3 => eax - U(1,2)
reg4	= const(2)
[eax,edx] = idiv(eax, reg4)
[reg5	:= edx]
reg6	= const(4)
reg7	= const(5)
U(6,7)	= add(reg6, reg7)
U(5,6,7)= add(reg5, U(6,7))

// 2.2 ещё развилка
eax		= const(10)
reg2	= const(3)
eax		= mul(eax, reg2)	// reg1 и reg2 имеют в этой точке равную длину => eax - первый из них
reg3	= const(1)
eax		= add(eax, reg3)
reg4	= const(2)
[eax,edx] = idiv(eax, reg4)
reg5	:= edx
reg6	= const(4)
reg7	= const(5)
U(6,7)	= add(reg6, reg7)
U(5,6,7)= add(reg5, U(6,7))

// 3. Результат - eax
eax		= const(10)
reg2	= const(3)
eax		= mul(eax, reg2)
reg3	= const(1)
eax		= add(eax, reg3)
reg4	= const(2)
[eax,edx] = idiv(eax, reg4)
[edx	:= edx]
eax		= const(4)
reg7	= const(5)
eax		= add(eax, reg7)	// равная длина => eax - первый из них
eax		= add(@eax, edx)	// eax; т.к. reg5 - edx, то eax может быть только U(6,7); тут же переставляем аргументы и отмечаем что выбор порядка сделан

// 4. Распределяем оставшиеся регистры по порядку
// При определении занятых в данный момент регистров нам требуется информация как о захвате, так и об освобождении регистров.
// Для определения точки освобождения можно конечно найти точку последнего использования регистра, пролистав зависимости вниз.
// Но лучше вместо этого договориться о том, что каждая команда, использующая регистр и не возвращающая в нём результат освобождает его.
// Т.е. если регистр захвачен любой командой, то он будет считаться используемым до точки явного освобождения.
eax		= const(10)			// занято:[a]			// Захват a
reg2	= const(3)			// занято:[a,reg2]		// Захват reg2
eax		= mul(eax, reg2)	// занято:[a,reg2]		// Освобождение reg2
reg3	= const(1)			// занято:[a,reg3]		// Захват reg3
eax		= add(eax, reg3)	// занято:[a,reg3]		// Освобождение reg3
reg4	= const(2)			// занято:[a,reg4]		// Захват reg4
[eax,edx] = idiv(eax, reg4)	// занято:[a,d,reg4]	// Освобождение eax и reg4; захват eax и edx; освобождение eax;
													// (для этой команды - особый освободитель регистра, регистрирующий, навешен ли
													// потребитель регистра или нет; если нет - автоматическое освобождение тут же)
eax		= const(4)			// занято:[a,d]			// Захват a
reg7	= const(5)			// занято:[a,d,reg7]	// Захват reg7
eax		= add(eax, reg7)	// занято:[a,d,reg7]	// Освобождение reg7
eax		= add(@eax, edx)	// занято:[a,d]			// Освобождение edx

// Т.о. мы видим что нам потребуется не более трёх регистров.
// Т.к. тут уже безразлично, какой регистр используется в не подставленных точках,
// то для каждого reg выбираем первый из тех, что не пересекается с ним по времени жизни.
// В частности, везде можно подставить ebx.

// Получаем:
eax		= const(10)			// занято:[a]
ebx		= const(3)			// занято:[a,b]
eax		= mul(eax, ebx)		// занято:[a,b]
ebx		= const(1)			// занято:[a,b]
eax		= add(eax, ebx)		// занято:[a,b]
ebx		= const(2)			// занято:[a,b]		// В этой точке edx не используется, однако занять его нельзя,
												// т.к. время жизни reg4 пересекается с явной аллокацией edx (следующая строка).
[eax,edx] = idiv(eax, ebx)	// занято:[a,d,b]
eax		= const(4)			// занято:[a,d]
ebx		= const(5)			// занято:[a,d,b]
eax		= add(eax, ebx)		// занято:[a,d,b]
eax		= add(@eax, edx)	// занято:[a,d]

// Итого:
eax		= const(10)			// занято:[a]		// mov  eax, 10
ebx		= const(3)			// занято:[a,b]		// mov  ebx, 3
eax		= mul(eax, ebx)		// занято:[a,b]		// imul eax, ebx
ebx		= const(1)			// занято:[a,b]		// mov  ebx, 1
eax		= add(eax, ebx)		// занято:[a,b]		// add  eax, ebx
ebx		= const(2)			// занято:[a,b]		// mov  ebx, 2
[eax,edx] = idiv(eax, ebx)	// занято:[a,d,b]	// idiv ebx			// А можно было и так: +(4+5) <=> + 4 + 5
eax		= const(4)			// занято:[a,d]		// mov  eax, 4		// mov eax, 4
ebx		= const(5)			// занято:[a,d,b]	// mov  ebx, 5		// add eax, edx
eax		= add(eax, ebx)		// занято:[a,d,b]	// add  eax, ebx	// mov edx, 5
eax		= add(@eax, edx)	// занято:[a,d]		// add  eax, edx	// add eax, edx
																	// Что на 1 регистр меньше по потреблению.
																	
/// ///////////////////////////////////////////////////////////////////////////
/// Оптимизации.
/// 1. Следует производить сортировку по длине зависимостей, чтобы регистры имели минимальное время жизни, а более длинному коду доставалось больше регистров.
///		НЕТ: по числу регистров или, возможно, в зависимости от количества "конфликтных ситуаций" при каждом перестроении дерева (нужен минимум, идём от малых поддеревьев к бОльшим).
/// 2. Следует раскладывать некоторые алгебраические операции, в частности, скобки - это упрощает распределение регистров,
///	позволяя заменить + (a - b) на + a - b, т.е. убирает ветку, позволяя заменить её на += и -= операции.
// К сожалению, не всё можно так разложить:
// Пример:
//	1.	(1 + 10 * 3) % 2 + (4 + 5)
//		=> (приоритета операндов нет) =>
//		10 * 3 + 1 % 2 + 4 + 5
//
//	2.	(1 + 10 * 3) % 2 - (-(4 - 5) / (6 / 7)) =>
//		=> (приоритета операндов нет) =>
//		10 * 3 + 1 % 2 - (-4 + 5 / (6 / 7))
//
// А кое что раскладывать и вовсе неоптимально:
//	3.	3 * (4 + 5)
//		=> (приоритета операндов нет) =>
//		(3 * 4) + (3 * 5) - хуже
//		4 + 5 * 3 - лучше, хотя результат при генерации тот же что и раньше (зато, обратно, можно выполнять свёртку арифметических выражений).
// Итого, реально помогает только разложение операций одного уровня, в которых нет "/":
//		n-(a + b)         => n-a-b
//		(n * m) * (g * k) => n * m * g * k
//		n * m / (g * k)   => n * m / g / k - спорно, т.к. "/" медленнее умножения
/// 3. Свёртка констант, включая вычисление чистых функций и приведения типов:
///		NB: Для встроенных функций нужен признак того, чистая ли дання функция или нет (=> можно ли заменить sin(1234) на константу).
///		Заменять можно не все, например функцию типа random(1, 100) - нельзя.
/// 	2 + a + f(5) => 2 + f(5) + a => C + a, где C = 2 + f(5)
///		3 * (a - f(2))  => 3 * (-f(2)) + 3 * a - нет толку.
/// 4. 2. Проход шаблонов оптимизации, добавляющих использование "add reg, num", "add reg, stack_var" и "inc/dec"
// В частности, пример шаблона:
//	template
//		tmpA = const_int(val)
//		tmpC = +(tmpA, tmpB) | tmpC = +(tmpB, tmpA)
//	as
//		-> tmpC = +const(tmpB, val)
//
// Пример замены различных операций с константами и переменными специализированными:
//		a - 3:
//		mov eax, [...]	> mov eax, [...]
//		mov ecx, 3		> sub eax, 3
//		sub eax, ecx	>
//
//		3 - a:			> А.: - a + 3:		> Б.: так короче? Быстрее?
//		mov eax, 3		> mov eax, [...]	> mov eax, 3
//		mov ecx, [...]	> neg eax			> sub eax, [...]
//		sub eax, ecx	> add eax, 3		>
//
// При этом, если есть выбор, то лучше помещать в регистр переменную, а константу задавать прямо в команде.

/// ///////////////////////////////////////////////////////////////////////////
/// Как разрешать коллизии.
/// 1. Подстановка регистра снизу натыкается на уже определённый регистр сверху, не соответствующий подстановочному регистру.
1 % 2 - 3
reg1 = const(1)
reg2 = const(2)
[reg3,reg4] = idiv(reg1, reg2)
reg5 = const(3)
reg6 = sub(reg4, reg5)

// idiv:
eax = const(1)
reg2 = const(2)
[eax,edx] = idiv(eax, reg2)
reg5 = const(3)
reg6 = sub(edx, reg5)

// Результат в eax:
eax = const(1)
reg2 = const(2)
[eax,edx] = idiv(eax, reg2)
reg5 = const(3)
eax = sub(edx, reg5) // Коллизия: первый аргумент должен быть eax, но он уже определён как edx

// Очевидный выход - mov.
eax = const(1)
reg2 = const(2)
[eax,edx] = idiv(eax, reg2)
reg5 = const(3)
edx = sub(edx, reg5)	// Оставляем тут как было
eax = mov(edx)			// А ниже добавляем пересылку в нужный регистр

// После чего подставляем остальные регистры:
eax = const(1)					// mov eax, 1		занято:[a]
ebx = const(2)					// mov ebx, 2		занято:[ab]
[eax,edx] = idiv(eax, ebx)		// idiv ebx			занято:[abd]	// a и b освобождаются, после чего a создаётся и тут же освобождается
ebx = const(3)					// mov ebx, 3		занято:[bd]
edx = sub(edx, ebx)				// sub edx, eax		занято:[bd]		// b освобождается
eax = mov(edx)					// mov eax, edx		занято:[ad]		// d освобождается


/// 2. Две различные ветви параллельно используют один и тот же регистр, хотя свободные регистры ещё есть.
/// Важно чтобы одна ветвь не насрала в регистр, в котором хранится результат другой ветви.
// Пример, в котором для разрешения коллизии достаточно переставить местами две ветки выполнения.
(4 + 5) + (1 + 10 * 3) % 2

/// 3. Нехватка регистров.
// Очевидно, будем выпихивать в стек.
// ...

/// NB: также хорошо бы сохранять значения входящих несколько раз подвыражений, например:
d * (sin(a) - cos(b)) + c * (- cos(b) + sin(a))		// Сохранить тут значение "sin(a) - cos(b)" даже в стек дешевле чем вычислять его заново.
